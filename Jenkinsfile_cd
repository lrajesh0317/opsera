pipeline {
  agent { label 'k8s-master' }

  environment {
    KUBECONFIG_ID = 'kubeconfig-single'     // Jenkins Secret File with kubeconfig
    RELEASE       = 'hello'                 // Helm release name
    NAMESPACE     = 'hello'                 // Kubernetes namespace
    CHART_PATH    = 'hello-chart'           // Path to your chart in the repo/WS
  }

  parameters {
    string(name: 'NEXUS_HOST', defaultValue: '54.209.208.145', description: 'Nexus host/IP')
    string(name: 'NEXUS_PORT', defaultValue: '8082',           description: 'Nexus Docker (hosted) port')
    string(name: 'NEXUS_REPO', defaultValue: 'docker-hosted',  description: 'Nexus repo name')
    string(name: 'IMAGE_NAME', defaultValue: 'ci-demo',        description: 'Image name in Nexus')
    string(name: 'IMAGE_TAG',  defaultValue: '1',              description: 'Already-built image tag to deploy')
  }

  stages {
    stage('Helm Deploy') {
      steps {
        withCredentials([file(credentialsId: env.KUBECONFIG_ID, variable: 'KCFG')]) {
          sh '''
            set -e
            export KUBECONFIG="$KCFG"

            kubectl get ns ${NAMESPACE} || kubectl create ns ${NAMESPACE}

            helm upgrade --install ${RELEASE} ${CHART_PATH} \
              --namespace ${NAMESPACE} \
              --set image.repository="${NEXUS_HOST}:${NEXUS_PORT}/${NEXUS_REPO}/${IMAGE_NAME}" \
              --set image.tag="${IMAGE_TAG}" \
              --wait --timeout 5m

            kubectl -n ${NAMESPACE} rollout status deploy/${RELEASE} --timeout=120s

            kubectl -n ${NAMESPACE} get deploy,po,svc -o wide
          '''
        }
      }
    }
  }

  post {
    success { echo "Deployed ${params.NEXUS_HOST}:${params.NEXUS_PORT}/${params.NEXUS_REPO}/${params.IMAGE_NAME}:${params.IMAGE_TAG} to ${env.NAMESPACE}" }
    failure { echo  "Helm deploy failed (release: ${env.RELEASE})" }
  }
}
